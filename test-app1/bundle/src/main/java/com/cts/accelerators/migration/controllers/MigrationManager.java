package com.cts.accelerators.migration.controllers;

/**
 * This is the main controller class which is invoked for any kind of content migration service requests.
 * 
 * @author Cognizant
 */

import java.io.IOException;
import java.rmi.ServerException;
import java.security.AccessControlException;
import java.util.HashMap;
import java.util.Map;

import javax.jcr.RepositoryException;
import javax.jcr.Session;

import org.apache.commons.lang.StringUtils;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.sling.SlingServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.servlets.SlingAllMethodsServlet;
import org.apache.sling.commons.json.JSONException;
import org.apache.sling.commons.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.cts.accelerators.core.AcceleratorGenericConstants;
import com.cts.accelerators.core.dao.ConnectionManager;
import com.cts.accelerators.core.dto.AcceleratorServiceResponse;
import com.cts.accelerators.core.services.NotificationService;
import com.cts.accelerators.core.util.AcceleratorTaxonomyUtilis;
import com.cts.accelerators.core.util.AcceleratorUtils;
import com.cts.accelerators.migration.exceptions.AcceleratorException;
import com.cts.accelerators.migration.exceptions.AcceleratorFaultCode;
import com.cts.accelerators.migration.services.ContentImporterService;
import com.cts.accelerators.migration.services.ContentTransformerService;
import com.cts.accelerators.migration.services.ContentBackupService;
import com.cts.accelerators.migration.services.DamUploadService;
import com.cts.accelerators.migration.services.ReportGeneratorService;
import com.cts.accelerators.migration.services.SchemaService;
import com.cts.accelerators.migration.services.dto.ContentBackupServiceRequest;
import com.cts.accelerators.migration.services.dto.ContentBackupServiceResponse;
import com.cts.accelerators.migration.services.dto.ContentImporterServiceRequest;
import com.cts.accelerators.migration.services.dto.ContentImporterServiceResponse;
import com.cts.accelerators.migration.services.dto.ContentTransformerServiceRequest;
import com.cts.accelerators.migration.services.dto.ContentTransformerServiceResponse;
import com.cts.accelerators.migration.services.dto.DamUploadServiceRequest;
import com.cts.accelerators.migration.services.dto.DamUploadServiceResponse;
import com.cts.accelerators.migration.services.dto.NotificationServiceRequest;
import com.cts.accelerators.migration.services.dto.NotificationServiceResponse;
import com.cts.accelerators.migration.services.dto.ReportGeneratorServiceRequest;
import com.cts.accelerators.migration.services.dto.ReportGeneratorServiceResponse;
import com.cts.accelerators.migration.services.dto.SchemaServiceRequest;
import com.cts.accelerators.migration.services.dto.SchemaServiceResponse;

@SlingServlet(paths = "/bin/MigrationManager", methods = "POST", metatype = false)
public class MigrationManager extends SlingAllMethodsServlet {

	private static final long serialVersionUID = 2598426539166789515L;

	private static final Logger LOGGER = LoggerFactory
			.getLogger(MigrationManager.class);

	private static final String CLASS_NAME = MigrationManager.class.getName();

	@Reference
	private ContentBackupService backupService;

	@Reference
	private ContentTransformerService transformService;

	@Reference
	private DamUploadService damUploadService;

	@Reference
	private ContentImporterService importerService;

	@Reference
	private ReportGeneratorService reportService;

	@Reference
	private SchemaService schemaService;

	@Reference
	private NotificationService notificationService;

	/**
	 * This method overrides the doPost method which will also be used for
	 * servicing GET requests as well. @ param slingRequest - will contain all
	 * the necessary parameters required for migration run @ param slingResponse
	 * - will contain response generated by the application
	 */
	@Override
	protected void doPost(SlingHttpServletRequest slingRequest,
			SlingHttpServletResponse slingResponse) throws ServerException,
			IOException {
		long methodStartTime = System.currentTimeMillis();
		LOGGER.info("doPost || MigrationManager || start @ " + methodStartTime);

		JSONObject responseReceived;
		Session jcrSession = null;
		try {
			// jcrSession=ConnectionManager.getSessionFromSlingRequest(slingRequest);
			LOGGER.info("JCR SESSION INITIALISATION " + jcrSession);
			responseReceived = identifyServiceRequest(slingRequest);

			if (responseReceived != null) {
				slingResponse.getWriter().write(responseReceived.toString());
			} else {
				slingResponse.getWriter().write("Response was null");
			}

			// Get the user email address from the profile and send report
			Resource resouce = slingRequest.getResource();
			String emailAddress = AcceleratorUtils.getEmailAddress(resouce);
			LOGGER.debug("doPost || MigrationManager || email address || "
					+ emailAddress);
			if (StringUtils.isNotEmpty(emailAddress)) {
				NotificationServiceRequest notificationServiceRequest = new NotificationServiceRequest();
				notificationServiceRequest.setToEmail(emailAddress);
				notificationServiceRequest.setMessages(responseReceived);
				notificationServiceRequest
						.setRequestType(slingRequest
								.getParameter(AcceleratorGenericConstants.REQUEST_TYPE));
				NotificationServiceResponse notificationServiceResponse = (NotificationServiceResponse) notificationService
						.execute(notificationServiceRequest);
				LOGGER.info("Notification Service Status: "
						+ (notificationServiceResponse
								.isNotificationSuccessful() ? "SUCCESS"
								: "FAILURE"));
			}
		} catch (AcceleratorException e) {
			LOGGER.error("EXCEPTION IN MigrationManager doPost || "
					+ e.getMessage());
		} finally {
			if (null != jcrSession) {
				jcrSession.logout();
			}
		}
		LOGGER.info("Content Migration End | Current Time"
				+ System.currentTimeMillis());
		LOGGER.info("Content Migration Executed in:"
				+ String.valueOf(System.currentTimeMillis() - methodStartTime));
		LOGGER.info("doPost || MigrationManager || end");
	}

	@Override
	protected void doGet(SlingHttpServletRequest request,
			SlingHttpServletResponse response) throws ServerException,
			IOException {
		LOGGER.info("doGet || MigrationManager || Redirecting to doPost");
		doPost(request, response);
	}

	/**
	 * This method is used to identify the request and call the corresponding
	 * method for processing
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject identifyServiceRequest(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "identifyServiceRequest";
		LOGGER.info(" || " + methodName + " || START");

		JSONObject finalServiceResponse = null;

		if (AcceleratorGenericConstants.GENERATE_SAMPLE_XSD.equals(request
				.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = generateXSD(request);
		} else if (AcceleratorGenericConstants.CONTENT_BACKUP
				.equalsIgnoreCase(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = createContentCopy(request);
		} else if (AcceleratorGenericConstants.CONTENT_TRANSFORMER
				.equalsIgnoreCase(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = startContentTransformation(request);
		} else if (AcceleratorGenericConstants.DAM_BULK_UPLOAD
				.equalsIgnoreCase(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = startDAMBulkUpload(request);
		} else if (AcceleratorGenericConstants.CONTENT_IMPORTER
				.equalsIgnoreCase(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = startContentImport(request);
		} else if (AcceleratorGenericConstants.COMPLETE_MIGRATION_PROCESS
				.equals(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = oneStepMigration(request);
		} else if (AcceleratorGenericConstants.SHOW_MIGRATION_REPORT
				.equals(request
						.getParameter(AcceleratorGenericConstants.REQUEST_TYPE))) {
			finalServiceResponse = showMigrationReport(request);
		} else if (AcceleratorGenericConstants.EXTRACT_SOURCE == request
				.getParameter(AcceleratorGenericConstants.REQUEST_TYPE)) {
			// Yet to be implemented
			finalServiceResponse = extractSourceContent(request);
		}
		LOGGER.debug(" || " + methodName + " || finalServiceResponse || "
				+ finalServiceResponse);
		LOGGER.info(" || " + methodName + " || END");
		return finalServiceResponse;
	}

	/**
	 * This method will go through an AEM application dependent DTOs and create
	 * a XSD that can be used as reference for creating application specific
	 * XMLs
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject generateXSD(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "generateXSD";
		LOGGER.info(" || " + methodName + " || START");
		SchemaServiceResponse schemaResponse = new SchemaServiceResponse();
		SchemaServiceRequest schemaRequest = new SchemaServiceRequest();
		schemaRequest.setLoadDefault(false);
		schemaRequest.setRequestType(request
				.getParameter(AcceleratorGenericConstants.REQUEST_TYPE));
		schemaRequest.setMoveTo(request
				.getParameter(AcceleratorGenericConstants.MOVE_TO));
		schemaRequest
				.setStoragePath(request
						.getParameter(AcceleratorGenericConstants.DESTINATION_ROOT_PATH));
		schemaResponse = (SchemaServiceResponse) schemaService
				.execute(schemaRequest);
		LOGGER.info(" || " + methodName + " || END");
		return schemaResponse.getJsonResponse();
	}

	/**
	 * This method is called to take care of standalone content reading and
	 * copying exercise.
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject createContentCopy(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "createContentCopy";
		LOGGER.info(" || " + methodName + " || START");
		JSONObject jsonResponse = new JSONObject();
		ContentBackupServiceResponse contentReaderResponse = new ContentBackupServiceResponse();

		ContentBackupServiceRequest contentReaderRequest = new ContentBackupServiceRequest();
		contentReaderRequest.setCompleteMigration(false);

		contentReaderRequest.setSourceRootPath(request
				.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
		contentReaderRequest
				.setDestinationRootPath(request
						.getParameter(AcceleratorGenericConstants.DESTINATION_ROOT_PATH));

		contentReaderResponse = (ContentBackupServiceResponse) backupService
				.execute(contentReaderRequest);

		LOGGER.info(" || " + methodName + " || END");
		return contentReaderResponse.getJsonResponse();
	}

	/**
	 * This method is called to take care of standalone content transformation
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */

	private JSONObject startContentTransformation(
			SlingHttpServletRequest request) throws AcceleratorException {
		String methodName = "startContentTransformation";
		LOGGER.info(" || " + methodName + " || START");

		ContentTransformerServiceRequest transformRequest = new ContentTransformerServiceRequest();
		ContentTransformerServiceResponse transformResponse = new ContentTransformerServiceResponse();
		transformRequest.setLoadDefault(true);
		transformRequest.setCompleteMigration(false);
		JSONObject jsonResponse = new JSONObject();

		transformRequest
				.setTransformationOrder(request
						.getParameter(AcceleratorGenericConstants.TRANSFORMATION_ORDER));

		transformRequest.setSourceRootPath(request
				.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));

		transformRequest.setMappingFilePath(request
				.getParameter(AcceleratorGenericConstants.MAPPING_FILE_PATH));

		transformRequest
				.setDestinationRootPath(request
						.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH));
		transformRequest.setTransformationType(request
				.getParameter(AcceleratorGenericConstants.TRANFORMATION_TYPE));

		transformResponse = (ContentTransformerServiceResponse) transformService
				.execute(transformRequest);

		LOGGER.info(" || " + methodName + " || END");
		return transformResponse.getJsonResponse();
	}

	/**
	 * This method will be called to perform standalone bulk DAM upload either
	 * for XMLs or just plain digital assets
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject startDAMBulkUpload(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "startDAMBulkUpload";
		LOGGER.info(" || " + methodName + " || START");
		DamUploadServiceRequest damUploadRequest = new DamUploadServiceRequest();
		DamUploadServiceResponse damUploadResponse = new DamUploadServiceResponse();
		JSONObject jsonResponse = new JSONObject();
		damUploadRequest.setLoadDefault(true);
		damUploadRequest.setCompleteMigration(false);

		damUploadRequest.setSourceRootPath(request
				.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
		damUploadRequest
				.setCqRootPath(request
						.getParameter(AcceleratorGenericConstants.DESTINATION_ROOT_PATH));
		damUploadRequest
				.setFileDestinationRootPath(request
						.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH));
		damUploadRequest.setTransformationType("XML");
		LOGGER.info(" || " + methodName + " || destination path || "
				+ damUploadRequest.getFileDestinationRootPath());
		damUploadResponse = (DamUploadServiceResponse) damUploadService
				.execute(damUploadRequest);

		LOGGER.info(" || " + methodName + " || END");
		return damUploadResponse.getJsonResponse();

	}

	/**
	 * This method is called to take care of standalone content migration
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */

	private JSONObject startContentImport(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "startContentImport";
		LOGGER.info(" || " + methodName + " || START");

		ContentImporterServiceRequest importRequest = new ContentImporterServiceRequest();
		ContentImporterServiceResponse importResponse = new ContentImporterServiceResponse();

		// Get Report files
		Map<String, String> reportFilePaths = new HashMap<String, String>();
		ReportGeneratorServiceRequest reportRequest = new ReportGeneratorServiceRequest();
		reportRequest.setLoadDefault(true);
		reportRequest.setViewReport(false);
		reportRequest
				.setReportType(AcceleratorGenericConstants.COMPLETE_MIGRATION_PROCESS);
		reportFilePaths = ((ReportGeneratorServiceResponse) reportService
				.execute(reportRequest)).getReportFilePaths();

		// Set Import request values
		importRequest.setLoadDefault(false);
		importRequest.setCompleteMigration(false);
		String booleanValue = request
				.getParameter(AcceleratorGenericConstants.ENABLE_DUPLICATION);
		if (booleanValue != null
				&& booleanValue
						.equalsIgnoreCase(AcceleratorGenericConstants.TRUE)) {
			importRequest.setEnableDuplication(true);
		} else {
			importRequest.setEnableDuplication(false);
		}
		booleanValue = request
				.getParameter(AcceleratorGenericConstants.DISABLE_UPDATE);
		if (booleanValue != null
				&& booleanValue
						.equalsIgnoreCase(AcceleratorGenericConstants.TRUE)) {
			importRequest.setDisableUpdate(true);
		} else {
			importRequest.setDisableUpdate(true);
		}
		importRequest.setSourceRootPath(request
				.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));

		importRequest
				.setFileDestinationRootPath(request
						.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH));
		importRequest.setImportOrder(request
				.getParameter(AcceleratorGenericConstants.IMPORT_ORDER));
		importRequest.setPageStoragePath(request
				.getParameter(AcceleratorGenericConstants.PAGE_PATH));
		importRequest.setDamStoragePath(request
				.getParameter(AcceleratorGenericConstants.DAM_ASSET_PATH));
		importRequest.setTaxonomyStoragePath(request
				.getParameter(AcceleratorGenericConstants.TAXONOMY_PATH));
		HashMap<String, String> importReportMap = new HashMap<String, String>();
		importReportMap.put(AcceleratorGenericConstants.IMPORT_REPORT,
				reportFilePaths.get(AcceleratorGenericConstants.IMPORT_REPORT));
		importReportMap.put(AcceleratorGenericConstants.DAM_REPORT,
				reportFilePaths.get(AcceleratorGenericConstants.DAM_REPORT));
		importReportMap.put(AcceleratorGenericConstants.TAXONOMY_REPORT,
				reportFilePaths
						.get(AcceleratorGenericConstants.TAXONOMY_REPORT));
		importRequest.setReportRootPaths(importReportMap);
		importResponse = (ContentImporterServiceResponse) importerService
				.execute(importRequest);

		LOGGER.info(" || " + methodName + " || END");
		return importResponse.getJsonResponse();
	}

	/**
	 * This method will be called when the client has requested for complete
	 * migration run - Content Storage for reference - Content Transformation -
	 * Content Import - Migration Reports - Replications and Workflows
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject oneStepMigration(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "oneStepMigration";
		LOGGER.info(" || " + methodName + " || START");
		AcceleratorServiceResponse response = null;
		JSONObject jsonResponse = new JSONObject();
		JSONObject transformJsonResponse = new JSONObject();
		JSONObject importJsonResponse = null;
		String reportPath = "";
		// Get Report Paths
		Map<String, String> reportFilePaths = new HashMap<String, String>();
		ReportGeneratorServiceRequest reportRequest = new ReportGeneratorServiceRequest();

		StringBuilder statusDescription = new StringBuilder();
		boolean permissionDenied = false;
		Session jcrSession = ConnectionManager.getSession();
		// Session
		// jcrSession=ConnectionManager.getSessionFromSlingRequest(request);
		String pagePath = request
				.getParameter(AcceleratorGenericConstants.PAGE_PATH);
		String damPath = request
				.getParameter(AcceleratorGenericConstants.DAM_ASSET_PATH);
		String tagId = request
				.getParameter(AcceleratorGenericConstants.TAXONOMY_PATH);
		String tagPath = AcceleratorTaxonomyUtilis.getMappedTagPath(tagId);
		LOGGER.info("pagePath: " + pagePath + " damPath: " + damPath
				+ " tagPath: " + tagPath);
		try {
			jcrSession.checkPermission(pagePath, Session.ACTION_ADD_NODE);
			jcrSession.checkPermission(damPath, Session.ACTION_ADD_NODE);
			if (StringUtils.isNotEmpty(tagPath)) {
				jcrSession.checkPermission(tagPath, Session.ACTION_ADD_NODE);
			}
		} catch (AccessControlException e1) {
			LOGGER.error("An exception occred in checkpermission", e1);
			permissionDenied = true;
			statusDescription
					.append("User does not have permission to create new node under the page path or dam path or tag path entered! Please check the permission;");
		} catch (RepositoryException e1) {
			LOGGER.error("An exception occred in checkpermission", e1);
		}

		if (permissionDenied) {
			try {
				jsonResponse.put(AcceleratorGenericConstants.STATUS,
						AcceleratorGenericConstants.STATUS_FAILURE);
				jsonResponse.put(AcceleratorGenericConstants.DESCRIPTION,
						statusDescription.toString());
				return jsonResponse;
			} catch (JSONException e1) {
				LOGGER.error(
						methodName + " || An exception occred || "
								+ e1.getMessage(), e1);
			}
		}
		try {
			reportRequest.setLoadDefault(true);
			reportRequest.setViewReport(false);
			reportRequest
					.setReportType(AcceleratorGenericConstants.COMPLETE_MIGRATION_PROCESS);
			reportFilePaths = ((ReportGeneratorServiceResponse) reportService
					.execute(reportRequest)).getReportFilePaths();

			ContentBackupServiceRequest backupRequest = new ContentBackupServiceRequest();
			ContentTransformerServiceRequest transformRequest = new ContentTransformerServiceRequest();
			ContentImporterServiceRequest importRequest = new ContentImporterServiceRequest();
			String readFromConfig = request
					.getParameter(AcceleratorGenericConstants.READ_FROM_CONFIG);
			LOGGER.debug(" || " + methodName + " || readFromConfig || "
					+ readFromConfig);
			if (readFromConfig != null
					&& readFromConfig
							.equalsIgnoreCase(AcceleratorGenericConstants.YES)) {
				importRequest.setLoadDefault(true);
			} else {
				LOGGER.debug(" || " + methodName + " || readFromConfig no");
				importRequest.setLoadDefault(false);
			}
			transformRequest.setLoadDefault(true);

			// Start content Backup
			backupRequest.setCompleteMigration(true);
			backupRequest
					.setSourceRootPath(request
							.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
			backupRequest
					.setDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.BACKUP);
			backupRequest.setMoveTo(AcceleratorGenericConstants.FILE_SYSTEM);
			backupRequest.setReportFilePath(reportFilePaths
					.get(AcceleratorGenericConstants.BACKUP_REPORT));
			jsonResponse = ((ContentBackupServiceResponse) backupService
					.execute(backupRequest)).getJsonResponse();
			if (null != jsonResponse
					&& jsonResponse.has(AcceleratorGenericConstants.STATUS)) {
				if (jsonResponse.get(AcceleratorGenericConstants.STATUS)
						.equals(AcceleratorGenericConstants.STATUS_FAILURE)) {
					return jsonResponse;
				}
			}

			// TODO loop over source path folders and check transformation order
			// with folder name

			// Transform Content
			transformRequest.setCompleteMigration(true);
			transformRequest.setReportFilePath(reportFilePaths
					.get(AcceleratorGenericConstants.TRANSFORMATION_REPORT));
			LOGGER.debug(" || " + methodName + " || report File path || "
					+ transformRequest.getReportFilePath());

			transformRequest
					.setSourceRootPath(request
							.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
			LOGGER.debug(" || " + methodName + " || source root path || "
					+ transformRequest.getSourceRootPath());

			transformRequest
					.setMappingFilePath(request
							.getParameter(AcceleratorGenericConstants.MAPPING_FILE_PATH));
			LOGGER.debug(" || " + methodName + " || mapping file || "
					+ transformRequest.getMappingFilePath());

			transformRequest
					.setDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.TRANSFORM);
			LOGGER.debug(" || " + methodName + " || file destination path || "
					+ transformRequest.getDestinationRootPath());

			transformRequest
					.setTransformationType(request
							.getParameter(AcceleratorGenericConstants.TRANFORMATION_TYPE));
			LOGGER.debug(" || " + methodName + " || transformer type || "
					+ transformRequest.getTransformationType());

			// Import Content
			HashMap<String, String> importReportMap = new HashMap<String, String>();
			importReportMap.put(AcceleratorGenericConstants.IMPORT_REPORT,
					reportFilePaths
							.get(AcceleratorGenericConstants.IMPORT_REPORT));
			importReportMap
					.put(AcceleratorGenericConstants.DAM_REPORT,
							reportFilePaths
									.get(AcceleratorGenericConstants.DAM_REPORT));
			importReportMap.put(AcceleratorGenericConstants.TAXONOMY_REPORT,
					reportFilePaths
							.get(AcceleratorGenericConstants.TAXONOMY_REPORT));
			importRequest.setReportRootPaths(importReportMap);
			importRequest.setCompleteMigration(true);
			importRequest
					.setEnableDuplication(request
							.getParameter(
									AcceleratorGenericConstants.ENABLE_DUPLICATE_PAGE_CREATION)
							.equals(AcceleratorGenericConstants.CHECKBOX_CHECKED) ? true
							: false);
			importRequest.setDisableUpdate(request.getParameter(
					AcceleratorGenericConstants.DISABLE_AUTO_UPDATE).equals(
					AcceleratorGenericConstants.CHECKBOX_CHECKED) ? true
					: false);
			importRequest.setEnableReplication(request.getParameter(
					AcceleratorGenericConstants.ENABLE_REPLICATION)
					.equalsIgnoreCase(AcceleratorGenericConstants.YES) ? true
					: false);
			importRequest
			.setTransformationType(request
					.getParameter(AcceleratorGenericConstants.TRANFORMATION_TYPE));
			if(importRequest.getTransformationType().equalsIgnoreCase(AcceleratorGenericConstants.XML)) {
				importRequest.setSourceRootPath(transformRequest
						.getDestinationRootPath()
						+ AcceleratorGenericConstants.FORWARD_SLASH
						+ AcceleratorGenericConstants.STATUS_SUCCESS);
			} else {
				importRequest.setSourceRootPath(request
						.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
			}
			importRequest
					.setFileDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.IMPORT);
			importRequest.setPageStoragePath(request
					.getParameter(AcceleratorGenericConstants.PAGE_PATH));
			importRequest.setDamStoragePath(request
					.getParameter(AcceleratorGenericConstants.DAM_ASSET_PATH));
			importRequest.setTaxonomyStoragePath(request
					.getParameter(AcceleratorGenericConstants.TAXONOMY_PATH));
			

			String[] importOrder = request.getParameter(
					AcceleratorGenericConstants.IMPORT_ORDER).split(
					AcceleratorGenericConstants.CSV_SEPARATOR);
			for (String order : importOrder) {
				transformRequest.setTransformationOrder(order);
				if (transformRequest.getTransformationType().equalsIgnoreCase(
						"XML")) {
					transformJsonResponse = ((ContentTransformerServiceResponse) transformService
							.execute(transformRequest)).getJsonResponse();
				} else if (transformRequest.getTransformationType()
						.equalsIgnoreCase("EXCEL")) {
					transformJsonResponse.put(
							AcceleratorGenericConstants.STATUS,
							AcceleratorGenericConstants.STATUS_SUCCESS);
				}
				if (null != transformJsonResponse
						&& transformJsonResponse
								.has(AcceleratorGenericConstants.STATUS)) {
					if (transformJsonResponse.get(
							AcceleratorGenericConstants.STATUS).equals(
							AcceleratorGenericConstants.STATUS_FAILURE)) {
						return transformJsonResponse;
					}
				}
				importRequest.setImportOrder(order);
				importRequest.setJsonResponse(importJsonResponse);
				importJsonResponse = ((ContentImporterServiceResponse) importerService
						.execute(importRequest)).getJsonResponse();
				LOGGER.info(" || " + methodName + " || importJsonResponse || "
						+ importJsonResponse);
			}
			jsonResponse = importJsonResponse;

			// for detailed report path, we need only till report folder path
			reportPath = jsonResponse.get(
					AcceleratorGenericConstants.REPORT_PATH).toString();
			jsonResponse
					.put(AcceleratorGenericConstants.REPORT_PATH,
							reportPath.substring(
									0,
									reportPath
											.lastIndexOf(AcceleratorGenericConstants.FORWARD_SLASH)));

		} catch (JSONException e) {
			LOGGER.error("An exception has occured in " + methodName, e);
			throw new AcceleratorException(AcceleratorFaultCode.JSON_EXCEPTION,
					CLASS_NAME, methodName, e.getCause());
		}

		// Send the response
		LOGGER.info(" || " + methodName + " || jsonResponse || " + jsonResponse);
		LOGGER.info(" || " + methodName + " || END");
		return jsonResponse;
	}

	private JSONObject oneStepMigrationBackup(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "oneStepMigration";
		LOGGER.info(" || " + methodName + " || START");
		AcceleratorServiceResponse response = null;
		JSONObject jsonResponse = new JSONObject();
		// Get Report Paths
		Map<String, String> reportFilePaths = new HashMap<String, String>();
		ReportGeneratorServiceRequest reportRequest = new ReportGeneratorServiceRequest();

		/*
		 * StringBuilder statusDescription=new StringBuilder(); boolean
		 * permissionDenied=false; Session
		 * jcrSession=ConnectionManager.getSessionFromSlingRequest(request);
		 * String pagePath=request
		 * .getParameter(AcceleratorGenericConstants.PAGE_PATH); String
		 * damPath=request
		 * .getParameter(AcceleratorGenericConstants.DAM_ASSET_PATH); String
		 * tagPath=request
		 * .getParameter(AcceleratorGenericConstants.TAXONOMY_PATH);
		 * 
		 * try { jcrSession.checkPermission(pagePath, Session.ACTION_ADD_NODE);
		 * jcrSession.checkPermission(damPath, Session.ACTION_ADD_NODE); } catch
		 * (AccessControlException e1) { permissionDenied=true;
		 * statusDescription.append(
		 * "User does not have permission to create new node under the page path or dam path or tag path entered! Please check the permission;"
		 * ); } catch (RepositoryException e1) { permissionDenied=true;
		 * statusDescription.append(
		 * "User does not have permission to create new node under the page path or dam path or tag path entered! Please check the permission;"
		 * ); }
		 * 
		 * if(permissionDenied) { try {
		 * jsonResponse.put(AcceleratorGenericConstants.STATUS,
		 * AcceleratorGenericConstants.STATUS_FAILURE);
		 * jsonResponse.put(AcceleratorGenericConstants.DESCRIPTION,
		 * statusDescription.toString()); return jsonResponse; } catch
		 * (JSONException e1) { // TODO Auto-generated catch block
		 * e1.printStackTrace(); } }
		 */
		try {
			reportRequest.setLoadDefault(true);
			reportRequest.setViewReport(false);
			reportRequest
					.setReportType(AcceleratorGenericConstants.COMPLETE_MIGRATION_PROCESS);
			reportFilePaths = ((ReportGeneratorServiceResponse) reportService
					.execute(reportRequest)).getReportFilePaths();

			ContentBackupServiceRequest backupRequest = new ContentBackupServiceRequest();
			ContentTransformerServiceRequest transformRequest = new ContentTransformerServiceRequest();
			ContentImporterServiceRequest importRequest = new ContentImporterServiceRequest();
			String readFromConfig = request
					.getParameter(AcceleratorGenericConstants.READ_FROM_CONFIG);
			LOGGER.debug(" || " + methodName + " || readFromConfig || "
					+ readFromConfig);
			if (readFromConfig != null
					&& readFromConfig
							.equalsIgnoreCase(AcceleratorGenericConstants.YES)) {
				importRequest.setLoadDefault(true);
			} else {
				LOGGER.debug(" || " + methodName + " || readFromConfig no");
				importRequest.setLoadDefault(false);
			}
			transformRequest.setLoadDefault(true);

			// Start content Backup
			backupRequest.setCompleteMigration(true);
			backupRequest
					.setSourceRootPath(request
							.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
			backupRequest
					.setDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.BACKUP);
			backupRequest.setMoveTo(AcceleratorGenericConstants.FILE_SYSTEM);
			backupRequest.setReportFilePath(reportFilePaths
					.get(AcceleratorGenericConstants.BACKUP_REPORT));
			jsonResponse = ((ContentBackupServiceResponse) backupService
					.execute(backupRequest)).getJsonResponse();
			if (null != jsonResponse
					&& jsonResponse.has(AcceleratorGenericConstants.STATUS)) {
				if (jsonResponse.get(AcceleratorGenericConstants.STATUS)
						.equals(AcceleratorGenericConstants.STATUS_FAILURE)) {
					return jsonResponse;
				}
			}

			// Transform Content
			transformRequest.setCompleteMigration(true);
			transformRequest.setReportFilePath(reportFilePaths
					.get(AcceleratorGenericConstants.TRANSFORMATION_REPORT));
			LOGGER.debug(" || " + methodName + " || report File path || "
					+ transformRequest.getReportFilePath());

			transformRequest
					.setSourceRootPath(request
							.getParameter(AcceleratorGenericConstants.SOURCE_ROOT_PATH));
			LOGGER.debug(" || " + methodName + " || source root path || "
					+ transformRequest.getSourceRootPath());

			transformRequest
					.setMappingFilePath(request
							.getParameter(AcceleratorGenericConstants.MAPPING_FILE_PATH));
			LOGGER.debug(" || " + methodName + " || mapping file || "
					+ transformRequest.getMappingFilePath());

			transformRequest
					.setDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.TRANSFORM);
			LOGGER.debug(" || " + methodName + " || file destination path || "
					+ transformRequest.getDestinationRootPath());
			transformRequest.setTransformationOrder(request
					.getParameter(AcceleratorGenericConstants.IMPORT_ORDER));
			LOGGER.debug(" || " + methodName + " || transformer order || "
					+ transformRequest.getTransformationOrder());
			transformRequest
					.setTransformationType(request
							.getParameter(AcceleratorGenericConstants.TRANFORMATION_TYPE));
			LOGGER.debug(" || " + methodName + " || transformer type || "
					+ transformRequest.getTransformationType());
			jsonResponse = ((ContentTransformerServiceResponse) transformService
					.execute(transformRequest)).getJsonResponse();
			if (null != jsonResponse
					&& jsonResponse.has(AcceleratorGenericConstants.STATUS)) {
				if (jsonResponse.get(AcceleratorGenericConstants.STATUS)
						.equals(AcceleratorGenericConstants.STATUS_FAILURE)) {
					return jsonResponse;
				}
			}

			// Import Content
			HashMap<String, String> importReportMap = new HashMap<String, String>();
			importReportMap.put(AcceleratorGenericConstants.IMPORT_REPORT,
					reportFilePaths
							.get(AcceleratorGenericConstants.IMPORT_REPORT));
			importReportMap
					.put(AcceleratorGenericConstants.DAM_REPORT,
							reportFilePaths
									.get(AcceleratorGenericConstants.DAM_REPORT));
			importReportMap.put(AcceleratorGenericConstants.TAXONOMY_REPORT,
					reportFilePaths
							.get(AcceleratorGenericConstants.TAXONOMY_REPORT));
			importRequest.setReportRootPaths(importReportMap);
			importRequest.setCompleteMigration(true);
			importRequest
					.setEnableDuplication(StringUtils.isNotEmpty(request
							.getParameter(AcceleratorGenericConstants.ENABLE_DUPLICATE_PAGE_CREATION)) ? true
							: false);
			importRequest
					.setDisableUpdate(StringUtils.isNotEmpty(request
							.getParameter(AcceleratorGenericConstants.DISABLE_AUTO_UPDATE)) ? true
							: false);
			importRequest.setEnableReplication(request.getParameter(
					AcceleratorGenericConstants.ENABLE_REPLICATION)
					.equalsIgnoreCase(AcceleratorGenericConstants.YES) ? true
					: false);
			importRequest.setSourceRootPath(transformRequest
					.getDestinationRootPath()
					+ AcceleratorGenericConstants.FORWARD_SLASH
					+ AcceleratorGenericConstants.STATUS_SUCCESS);
			importRequest
					.setFileDestinationRootPath(request
							.getParameter(AcceleratorGenericConstants.FILE_DESTINATION_PATH)
							+ AcceleratorGenericConstants.FORWARD_SLASH
							+ AcceleratorGenericConstants.IMPORT);
			importRequest.setImportOrder(request
					.getParameter(AcceleratorGenericConstants.IMPORT_ORDER));
			importRequest.setPageStoragePath(request
					.getParameter(AcceleratorGenericConstants.PAGE_PATH));
			importRequest.setDamStoragePath(request
					.getParameter(AcceleratorGenericConstants.DAM_ASSET_PATH));
			importRequest.setTaxonomyStoragePath(request
					.getParameter(AcceleratorGenericConstants.TAXONOMY_PATH));
			jsonResponse = ((ContentImporterServiceResponse) importerService
					.execute(importRequest)).getJsonResponse();
		} catch (JSONException e) {
			LOGGER.error("An exception has occured in " + methodName, e);
			throw new AcceleratorException(AcceleratorFaultCode.JSON_EXCEPTION,
					CLASS_NAME, methodName, e.getCause());
		}

		// Send the response
		LOGGER.info(" || " + methodName + " || END");
		return jsonResponse;
	}

	/**
	 * This method will provide a list of all the previous migration run and
	 * link to the migration report for detailed analysis.
	 * 
	 * @param request
	 * @return
	 * @throws AcceleratorException
	 */
	private JSONObject showMigrationReport(SlingHttpServletRequest request)
			throws AcceleratorException {
		String methodName = "showMigrationReport";
		LOGGER.info(" || " + methodName + " || START");

		ReportGeneratorServiceResponse reportResponse = null;

		ReportGeneratorServiceRequest reportRequest = new ReportGeneratorServiceRequest();
		reportRequest.setLoadDefault(true);
		if (null != request
				.getParameter(AcceleratorGenericConstants.REPORT_DATE)) {
			reportRequest.setReportDate(request
					.getParameter(AcceleratorGenericConstants.REPORT_DATE));
		}
		if (null != request
				.getParameter(AcceleratorGenericConstants.REPORT_TYPE)) {
			reportRequest.setReportType(request
					.getParameter(AcceleratorGenericConstants.REPORT_TYPE));
		}
		if (null != request
				.getParameter(AcceleratorGenericConstants.REPORT_DETAILS_TYPE)) {
			reportRequest
					.setReportDetailedType(request
							.getParameter(AcceleratorGenericConstants.REPORT_DETAILS_TYPE));
		}
		if (request.getParameter(AcceleratorGenericConstants.FILEPATH) != null) {
			String filePath = request
					.getParameter(AcceleratorGenericConstants.FILEPATH);
			reportRequest.setSpecificReportPath(filePath.replace("\\", "\\\\"));
		}
		boolean completeMigrationReports = false;
		if (request
				.getParameter(AcceleratorGenericConstants.INDIVIDUAL_OR_MIGARTION_REPORTS) != null) {
			completeMigrationReports = request
					.getParameter(
							AcceleratorGenericConstants.INDIVIDUAL_OR_MIGARTION_REPORTS)
					.equalsIgnoreCase(
							AcceleratorGenericConstants.MIGRATION_REPORTS) ? true
					: false;
		}
		reportRequest.setCompleteMigrationReports(completeMigrationReports);

		boolean isSpecificReport = false;
		if (request.getParameter(AcceleratorGenericConstants.SPECIFIC_REPORT) != null) {
			isSpecificReport = request.getParameter(
					AcceleratorGenericConstants.SPECIFIC_REPORT)
					.equalsIgnoreCase(AcceleratorGenericConstants.TRUE) ? true
					: false;
		}
		reportRequest.setSpecificReport(isSpecificReport);
		reportRequest.setViewReport(true);

		reportResponse = (ReportGeneratorServiceResponse) reportService
				.execute(reportRequest);

		if (reportResponse != null) {
			return reportResponse.getReportJsonResponse();
		}
		LOGGER.info(" || " + methodName + " || END");
		return null;
	}

	/**
	 * This method will be called to only extract content from a source system.
	 * This in turn will depend on a factory of content extractors to allow easy
	 * extension to meet future requirements.
	 * 
	 * @param request
	 * @return
	 */
	private JSONObject extractSourceContent(SlingHttpServletRequest request) {
		String methodName = "extractSourceContent";
		LOGGER.info(" || " + methodName + " || START");
		JSONObject jsonObj = new JSONObject();
		try {
			jsonObj.put(AcceleratorGenericConstants.EXTRACT_SOURCE_CONTENT,
					"Must be available as a separate option in the menu");
		} catch (JSONException e) {
			LOGGER.error("Exception occurred in " + methodName + " || "
					+ e.getMessage());
		}
		LOGGER.info(" || " + methodName + " || END");
		return jsonObj;
	}

}
